---
title: "על גרפים ועל פינגווינים עצלים"
date: 2019-10-25
---

import ImagePreview from "../../../src/components/ImagePreview.js";
import advancedGraph from "./AdvancedGraph.png";

#### חידה:

אני ו-$n$ פינגוויני בחדר. זה לא חדר נחמד בכלל ואני ממש ממש לא רוצה להישאר בו או להשאיר פינגווינים תמימים בו. אבל יש בעיה: הפינגווינים העצלנים לא רוצים לזוז, והיציאה היחידה מהחדר היא דרך דלת, שמקושרת לשעון, והשעון לא מחכה לאף פינגווין עצל.  
[תמונת פינגווינים פה]

עכשיו מגיעים לנתונים שמתקיימים באורח פלא, ולא סביר שנפגוש אותם במציאות:

1. הזמן שלוקח לי להגיע ממקום א׳ למקום ב׳ הוא לא סימטרי. **דוגמה:** ללכת לפינגווין מס׳ 1 מנקודת הפתיחה לוקחת 3 יחידות זמן, אך חזרה מפינגווין מס׳ 1 לנקודת הפתיחה יכולה לקחת 5 יחידות זמן. למה? ככה, זה הופך את החידה למעניינת.
2. יש מסלולים מסוימים שמעבר בהם מוסיף זמן לשעון. **דוגמה:** מעבר מהמיקום ההתחלתי אל הדלת, תוסיף 2 יחידות זמן לשעון. למה? נראה לי שכבר הבנתם.

אלה נתונים שדווקא יכול להתקיים במציאות:

3. יש לי במקסימום 5 פינגווינים. איך זה עוזר לנו? נגלה בהמשך.
4. הדלת פתוחה כל עוד השעון מראה זמן גדול שווה ל-0. זאת אומרת שאם הדלת כבר נסגרה כי השעון הגיע למינוס אחת, אבל עברנו במסלול כלשהו שהביא לנו עוד זמן והעלה את השעון ל-0 או יותר, הדלת תפתח שוב.

כמו כן, באורח פלא יש לי מחשב (לא המחשב הכי חזק בעולם, אבל הוא יכול להריץ כרום עם 30 טאבים בלי למות, וזה מספיק טוב). ובאורח פלא 2, אני יכולה לקחת פסק זמן ארוך כרצוני לפני כל הסיפור הזה, בשביל לתכנן אסטרטגיה טובה. מהי אסטרטגיה טובה? כזאת שתאפשר לי להציל כמה שיותר פינגווינים, בלי להיסגר בחדר לנצח (כי מה יעזור להוציא את הפינגווינים אם אף אחת לא תדאג להם שם בחוץ?), אם אני מגיעה לדלת כשהשעון מראה 0 זה מספיק טוב, ואני עדיין אוכל להימלט.

עד פה החידה.
בואו ננסה להבין איך נמצא אסטרטגיה טובה. אציין שעוד לא פתרתי את החידה ואני כותבת תוך כדי מהלך הפתרון שלה.
נרצה לכתוב פונקציה `getBestPath` המקבלת שני פרמטרים:
הראשון, מטריצה בשם `times` שמימדיה $(n+2)\times(n+2)$. המטריצה תגיע בפורמט הבא:
`times[i][j]`שווה לזמן שיקח לי להגיע מנקודה $i$ לנקודה $j$. הנקודות הן: נקודת ההתחלה, פינגווין 1, $...$, פינגווין $n$, דלת.

הפרמטר השני הוא מספר לא שלילי `timeLimit` שאומר כמה יחידות זמן מראה השעון בהתחלה.

לאורך המאמר נשתמש במטריצה הבאה:

$$
\begin{pmatrix}
0 & 1 & 2 & 1 & -1 \\
2 & 0 & 3 & 2 & 3 \\
2 & 2 & 0 & 3 & 2 \\
3 & 3 & 2 & 0 & 1 \\
2 & 1 & 1 & 1 & 0
\end{pmatrix}
$$

אני אסביר מה נובע מהמטריצה הזאת. בגלל שמימדיה הם 5 שורות על 5 עמודות, נובע שיש סה"כ 3 פינגווינים, כי השורה והעמודה הראשונה מייצגות את נקודת ההתחלה והשורה והעמודה האחרונה מייצגות את הדלת. גם נובע שמעבר מפינגווין מס' 2 לפינגווין מס' 3 לוקח 2 יחידות זמן (שורה שלישית, עמודה רביעית), ומעבר מהדלת לפינגווין מס' 2 מוסיף 1 יחידות זמן (שורה ראשונה, עמודה שלישית).

לי זו נראית כמו חידת גרפים קלאסית.
הגרף שלנו הוא **גרף מכוון** שבו לכל קשת משקל שלם (יכול להיות שלילי).
הצמתים הם: נקודת ההתחלה, צומת לכל פינגווין והדלת. נסמן אותם ב-$\{M,P1, …,Pn,D\}$. $M$ היא נקודת ההתחלה, $P1$ הוא צומת הפינגווין הראשון, $P2$ השני, עד $n$ ו-$D$ היא הדלת.
בין כל צומת יש קשת (הגרף הוא **גרף שלם**) שמשקלה נגזר מהמטריצה `times`. כדוגמה, בהנחה שהמטריצה בגודל $5\times 5$, המשקל של הקשת שמחברת בין פינגווין מס׳ 2 לדלת יהיה הערך `times[2][4]`.

הגרף שמתואר במטריצה שלמעלה נראה ככה:
![הגרף המקורי](./OriginalGraph.png)

אנחנו רוצים למצוא מסלול ש:

1. יתחיל בנקודת ההתחלה.
1. יעבור בכמה שיותר מצמתי הפינגווינים.
1. יסיים בדלת.
1. אורך המסלול (סכום משקלי הקשתות המרכיבות את המסלול) תהיה קטנה או שווה לזמן ההתחלתי,`timeLimit`.

קל. סתם, לא באמת קל.
למעשה זה מרגיש לי כל כך לא קל, שאני אציע כפתרון אפשרי אחד בסיבוכיות מטורפת.  
יש המון אלגוריתמים ידועים למציאת מסלולים קצרים בגרף. הבעיה היא שאנחנו רוצים למקסם את כמות צמתי הפינגווין שנעבור בהם.  
בשביל שנדע באילו מצמתי הפינגווינים כבר עברנו, נצטרך לשלב אלמנט של זכרון בגרף. נוסיף כמה שכבות לגרף (ז"א, נשכפל את הצמתים כמה פעמים) וכל שכבה כזו תסמל מצב שבו עברנו כבר בצמתי פינגווינים כלשהם. אני אסביר.  

אנחנו הולכים לשכפל את הצמתים מהגרף המקורי. כל שכפול כזה יקרא "שכבה" ויהיה כנגד תת-קבוצה של $P$ (קבוצת כל צמתי הפינגווין). כדוגמה, אם אנחנו בצומת $D$ בשכבה ${P1,P2}$ סימן שכבר עברנו לפחות פעם אחת בכל אחד מהצמתים שמתארים את פינגווין 1 ופינגווין 2, ושאנחנו נמצאים בצומת הדלת. אם יש לנו 3 פינגווינים סה"כ, יהיו לנו השכבות הבאות:  
$\{\}$ - השכבה ההתחלתית שאומרת שלא עברנו באף צומת פינגווין.  
$\{P1\}$, $\{P2\}$, $\{P3\}$ - כל אחת מהשכבות אומרת "עברנו רק בצומת פינגווין אחת (יכול להיות שכמה פעמים באותה הצומת)".  
$\{P1,P2\}$, $\{P2,P3\}$, $\{P1,P3\}$ - כל אחת מהשכבות אומרת שעברנו בשתי צמתי פינגווינים.  
$\{P1,P2,P3\}$ - שכבה שאומרת שעברנו בכל צמתי הפינגווינים.  
סה"כ 8 שכבות, או $2^3$ (כי יש סה"כ 3 פינגווינים).

כמו שאמרנו, כל שכבה היא שכפול של צמתי הגרף המקורי. נסמן צומת בגרף השכבות, שנוצרה מהצומת בגרף המקורי $x$ בשכבה $L$ כך: $x_L$. כדוגמה, את הצומת P3 בשכבה $\{1,2\}$ נסמן ב-$P3_{\{1,2\}}$.  
ככה יראה גרף השכבות של הגרף שהראיתי למעלה: (התמונה המלאה לא מוצגת מתוך רחמים על משתמשי המובייל)
<ImagePreview src={advancedGraph} alt="גרף שכבות" leftOffset="8%" />

נגדיר את הצמתים באופן פורמלי:
$$
V=\{ x_L | x\in\{M,P1, …,Pn, D\}, L\subseteq\{P1, …,Pn\} \}
$$

לכל צומת בגרף המקורי, ולכל תת קבוצה של צמתי פינגווינים, אנחנו מגדירים צומת בגרף החדש.  
נתרגם את זה לקוד:
